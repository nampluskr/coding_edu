## 250719 노후화된 도로

**[ 주의 사항 ]**

1. User Code 안에는 어떠한 헤더 파일도 추가할 수 없다.

   ( 단, malloc.h 사용 가능 )

2. Main 은 실제 채점 시에도 그대로 사용된다. 단, TC 의 갯수와 seed 값은 변경될 수 있다.

   ( 단, 치팅 방지를 위한 방어 코드가 추가 될 수 있다. )

3. 본 검정은 엄격한 코드 리뷰를 실시한다.

Main 에서 사용하는 변수에 직접적으로 접근하는 행위를 금지한다.

4. 본 검정은 C++ 언어만 지원한다.

5. 실제 채점 시 사용되는 테스트케이스의 갯수는 최대 100 개이다

 

▶ process() 함수를 작성하여, SCORE 를 최소로 만드시오.
 

기타 자세한 사항은 주어진 코드를 분석하여 파악하라.


### main.cpp
```cpp
#ifndef _CRT_SECURE_NO_WARNINGS

#define _CRT_SECURE_NO_WARNINGS

#endif



#include <stdio.h>



/* seed and pseudo_rand function will be changed */

static unsigned long long seed;



static int pseudo_rand(void) {

	seed = seed * 25214903917ULL + 11ULL;

	return (seed >> 16) & 0x3fffffff;

}



static long long gTotalScore = 0;

static long long PENALTY = 1000000000000;



/* These constant variables will NOT be changed */

static const int CITY_NUM = 1000;

static const int ROAD_NUM = 3000;

static const int FREIGHT_NUM = 2000;

static const int MAX_WEIGHT = 90;



struct Road {

	int city1;

	int city2;

	int status;

	int id;

};





struct Freight {

	int pos;

	int dest;

	int weight;

};



struct Truck {

	int pos;

	Freight* freight;

};



static Truck truck;

static Road roads[ROAD_NUM];

static Freight freights[FREIGHT_NUM];



////////////////////////////////////



bool move(int mRoadID, int repairNum)

{

	if (mRoadID < 0 || mRoadID >= ROAD_NUM || repairNum < 0 || repairNum + roads[mRoadID].status > 1000)

		return false;



	int totalWeight = 10 + ((truck.freight == nullptr) ? 0 : truck.freight->weight);

	int score = 10 + repairNum * totalWeight;





	if (repairNum + roads[mRoadID].status >= totalWeight) {

		if (truck.pos != roads[mRoadID].city1 && truck.pos != roads[mRoadID].city2)

			return false;



		if (truck.pos == roads[mRoadID].city1)

			truck.pos = roads[mRoadID].city2;

		else

			truck.pos = roads[mRoadID].city1;



		gTotalScore += score;

		roads[mRoadID].status += (repairNum - totalWeight);



		return true;

	}

	else {

		return false;

	}

}



bool load(int mFreightID)

{

	if (truck.freight != nullptr || truck.pos != freights[mFreightID].pos)

		return false;



	truck.freight = &freights[mFreightID];

	gTotalScore += truck.freight->weight * truck.freight->weight;



	return true;

}



bool unload()

{

	if (truck.freight == nullptr)

		return false;



	gTotalScore += truck.freight->weight * truck.freight->weight;



	truck.freight->pos = truck.pos;

	truck.freight = nullptr;



	return true;

}



void getRoadInfo(Road mRet[])

{

	for (int i = 0; i < ROAD_NUM; i++) {

		mRet[i] = roads[i];

	}

}



void getFreightInfo(Freight mRet[])

{

	for (int i = 0; i < FREIGHT_NUM; i++) {

		mRet[i] = freights[i];

	}

}



////////////////////////////////////

static void init()

{

	truck.pos = 0;

	truck.freight = nullptr;

	int roadIdx = 0;



	int citylist[CITY_NUM] = { 0, };



	for (int i = 0; i < CITY_NUM; i++)

		citylist[i] = i;



	int shuffle_cnt = 3000;



	for (int i = 0; i < 2; i++) {

		for (int j = 0; j < shuffle_cnt; j++) {

			int x = pseudo_rand() % CITY_NUM;

			int y = pseudo_rand() % CITY_NUM;



			int t = citylist[x];

			citylist[x] = citylist[y];

			citylist[y] = t;

		}



		for (int j = 0; j < CITY_NUM - 1; j++) {

			roads[roadIdx].city1 = citylist[j];

			roads[roadIdx].city2 = citylist[j + 1];

			roads[roadIdx].id = roadIdx;

			roads[roadIdx].status = pseudo_rand() % 300 + 100;



			roadIdx++;

		}

	}



	while (roadIdx < ROAD_NUM) {

		for (int j = 0; j < shuffle_cnt; j++) {

			int x = pseudo_rand() % CITY_NUM;

			int y = pseudo_rand() % CITY_NUM;



			int t = citylist[x];

			citylist[x] = citylist[y];

			citylist[y] = t;

		}



		int l = pseudo_rand() % CITY_NUM;



		if (roadIdx + l > ROAD_NUM) {

			l = ROAD_NUM - roadIdx;

		}



		int startIdx = pseudo_rand() % CITY_NUM;



		if (startIdx + l >= CITY_NUM) {

			startIdx = CITY_NUM - l - 1;

		}



		for (int j = 0; j < l; j++) {

			roads[roadIdx].city1 = citylist[j + startIdx];

			roads[roadIdx].city2 = citylist[j + startIdx + 1];

			roads[roadIdx].id = roadIdx;

			roads[roadIdx].status = pseudo_rand() % 300 + 100;



			roadIdx++;

		}

	}



	for (int i = 0; i < FREIGHT_NUM; i++) {

		freights[i].pos = pseudo_rand() % CITY_NUM;

		freights[i].dest = pseudo_rand() % CITY_NUM;

		freights[i].weight = pseudo_rand() % MAX_WEIGHT + 1;

	}



}



static bool score()

{

	for (int i = 0; i < FREIGHT_NUM; i++) {

		if (freights[i].pos != freights[i].dest)

			return false;

	}



	return true;

}



extern void process();



int main(int argc, char* argv[])

{

	setbuf(stdout, NULL);

//	freopen("sample_input.txt", "r", stdin);



	bool result = false;

	int TC;



	gTotalScore = 0;



	scanf("%d%lld", &TC, &seed);

	for (int tc = 0; tc < TC; ++tc) {

		init();

		process();

		if ((result = score()) == false)

			break;

	}

	long long SCORE = (result) ? gTotalScore : PENALTY;

	printf("SCORE: %lld\n", SCORE);



	return 0;

}
```

### user.cpp
```cpp
	
struct Road

{

	int city1;

	int city2;

	int status;

	int id;

};



struct Freight

{

	int pos;

	int dest;

	int weight;

};



extern bool move(int mRoadID, int repairNum);

extern bool load(int mFreightID);

extern bool unload();

extern void getRoadInfo(Road mRet[]);

extern void getFreightInfo(Freight mRet[]);





void process() {

}
```

### 풀이예 (박영규)

○  풀이

1) 인접리스트 생성

2) 최단거리 기준 ROUTE 설정 (BFS)

3) 가장 무거운 화물부터 찾아 배송

※ 이동 시 

기 작성한 ROUTE(1 → 3 → 5) 를 따라 이동하며 

단위경로 road가 다수인 경우 잔여 status가 가장 높은 도로 활용 (status 부족 시 repairNum 활용)

→   SCORE : 15'210'998 (예상 합격컷 : 11'18x'xxx)        

status 부족 시 최단거리가 아닌 잔여 status 기준으로 다익스트라를 돌리려 했으나 구현력 부족으로....ㅜ.ㅜ

```cpp
#define CITY_NUM 1000
#define ROAD_NUM 3000
#define FREIGHT_NUM 2000
#define MAX_WEIGHT 90
#include <stdio.h>

// 인접리스트
intadjList[CITY_NUM][50];
intcntAdj[CITY_NUM];

// 출발지, 목적지, 도로List
introadList[CITY_NUM][CITY_NUM][10];
intcntRoad[CITY_NUM][CITY_NUM];

// 출발지, 목적지, 최단경로List
intmoveList[CITY_NUM][CITY_NUM][10];
intcntMoveList[CITY_NUM][CITY_NUM];

int cntCompleted;

structState {
    intmoveList[100];
    boolvisited[1000] = {};
    int pos;
    int mwp;
};

structQueue {
    State arr[1000];
    int wp, rp;
    voidinit() { wp = rp =0; }
    voidpush(Stateval) { arr[wp++] = val; }
    Statepop() { returnarr[rp++]; }
    boolisEmpty() { return wp == rp; }
};

Queue queue;

structRoad
{
    int city1;
    int city2;
    int status;
    int id;
};

Road roadInfo[ROAD_NUM];

structFreight
{
    int pos;
    int dest;
    int weight;
};

Freight freightInfo[FREIGHT_NUM];
int fId;

structTruck {
    int pos;
    Freight* freight;
};
Truck myTruck;

longlong myScore;

externboolmove(intmRoadID, intrepairNum);
externboolload(intmFreightID);
externboolunload();
externvoidgetRoadInfo(RoadmRet[]);
externvoidgetFreightInfo(FreightmRet[]);

boolmyMove(intmRoadID, intrepairNum)
{
    move(mRoadID, repairNum);
    if (mRoadID <0|| mRoadID >= ROAD_NUM || repairNum <0|| repairNum +roadInfo[mRoadID].status>1000)
        returnfalse;

    int totalWeight =10+ ((myTruck.freight==nullptr) ?0:myTruck.freight->weight);
    int score =10+ repairNum * totalWeight;

    if (repairNum +roadInfo[mRoadID].status>= totalWeight) {
        if (myTruck.pos!=roadInfo[mRoadID].city1&&myTruck.pos!=roadInfo[mRoadID].city2)
            returnfalse;

        if (myTruck.pos==roadInfo[mRoadID].city1)
            myTruck.pos=roadInfo[mRoadID].city2;
        else
            myTruck.pos=roadInfo[mRoadID].city1;

        myScore += score;
        roadInfo[mRoadID].status+= (repairNum - totalWeight);

        returntrue;
    }
    else
        returnfalse;
}



boolmyLoad(intmFreightID)
{
    load(mFreightID);
    if (myTruck.freight!=nullptr||myTruck.pos!=freightInfo[mFreightID].pos)
        returnfalse;


    myTruck.freight=&freightInfo[mFreightID];
    myScore +=myTruck.freight->weight*myTruck.freight->weight;


    returntrue;
}


boolmyUnload()
{
    unload();
    if (myTruck.freight==nullptr)
        returnfalse;


    myScore +=myTruck.freight->weight*myTruck.freight->weight;


    myTruck.freight->pos=myTruck.pos;
    myTruck.freight=nullptr;
    cntCompleted++;
    //printf("cntCompleted : %d, fId : %d\n", cntCompleted, fId);
    returntrue;
}


intgetDest()
{
    int maxWeight =0;
    int maxPos =-1;
    for (int i =0; i < FREIGHT_NUM; i++) {
        if (freightInfo[i].pos==freightInfo[i].dest)
            continue;
        if (maxWeight <freightInfo[i].weight) {
            maxWeight =freightInfo[i].weight;
            maxPos =freightInfo[i].pos;
            fId = i;
        }
    }


    if (maxPos >-1)
        return maxPos;
    else
        return-1;
}


intbestRoute[CITY_NUM];


voidmakeRoute(intpos)
{
    int bestRoad =0;
    int bestStatus =0;


    queue.init();
    State state;
    state.pos= pos;
    state.mwp=0;
    state.moveList[state.mwp++] = pos;
    state.visited[state.pos] =true;
    queue.push(state);
    while (!queue.isEmpty()) {
        State prev =queue.pop();
        for (int dIdx =0; dIdx <cntAdj[prev.pos]; dIdx++) {
            int d =adjList[prev.pos][dIdx];
            // 이미 경로가 있으면 Continue;
            if (cntMoveList[pos][d] >0)
                continue;
            if (prev.pos== d ||prev.visited[d])
                continue;
            if (cntRoad[prev.pos][d] ==0)
                continue;


            // next 생성 및 prev 값 복사
            State next;
            next.mwp=prev.mwp;
            next.pos=prev.pos;
            for (int i =0; i <next.mwp; i++) {
                next.moveList[i] =prev.moveList[i];
                int visitPos =next.moveList[i];
                next.visited[visitPos] =true;
            }


            next.moveList[next.mwp++] = d;
            next.visited[d] =true;
            next.pos= d;


            // 경로가 없을 경우 Queue에 넣고 경로 Update
            queue.push(next);
            cntMoveList[pos][d] =next.mwp;
            for (int i =0; i <cntMoveList[pos][d]; i++)
                moveList[pos][d][i] =next.moveList[i];
        }
    }
}


voidmoveTruck(intsource, intdest)
{
    int current =0;
    int to =0;

    for (int i =1; i <cntMoveList[source][dest]; i++) {
        int bestRoadId =0;
        int maxStatus =0;
        current =moveList[source][dest][i -1];
        to =moveList[source][dest][i];
        for (int j =0; j <cntRoad[current][to]; j++) {
            int roadId =roadList[current][to][j];
            if (maxStatus <=roadInfo[roadId].status) {
                maxStatus =roadInfo[roadId].status;
                bestRoadId = roadId;
            }
        }
        int totalWeight =10+ ((myTruck.freight==nullptr) ?0:myTruck.freight->weight);
        int repairNum = totalWeight -roadInfo[bestRoadId].status>0? totalWeight -roadInfo[bestRoadId].status:0;
        //printf("repairNum : %d\n", repairNum);
        myMove(bestRoadId, repairNum);
    }
}

voidinit()
{
    cntCompleted =0;
    for (int i =0; i < CITY_NUM; i++)
        cntAdj[i] =0;
    for (int i =0; i < CITY_NUM; i++) {
        for (int j =0; j < CITY_NUM; j++) {
            cntRoad[i][j] =0;
            cntMoveList[i][j] =0;
        }
    }
}

voidprocess() {
    init();

    getRoadInfo(roadInfo);
    getFreightInfo(freightInfo);

    // 배송 안해도 되는 화물 처리
    for (int i =0; i < FREIGHT_NUM; i++)
        if (freightInfo[i].pos==freightInfo[i].dest)
            cntCompleted++;

    // 인접리스트 구현
    for (int i =0; i < ROAD_NUM; i++) {
        int s =roadInfo[i].city1;
        int d =roadInfo[i].city2;
        roadList[s][d][cntRoad[s][d]++] = i;
        roadList[d][s][cntRoad[d][s]++] = i;
        if (cntRoad[s][d] ==1)
            adjList[s][cntAdj[s]++] = d;
        if (cntRoad[d][s] ==1)
            adjList[d][cntAdj[d]++] = s;
    }

    // 이동경로 만들기
    for (int i =0; i < CITY_NUM; i++)
        makeRoute(i);

    myTruck.pos=0;

    while (1) {
        // 가장 무거운 화물로 이동
        int dest =getDest();
        if (dest ==-1)
            break;
        int source =myTruck.pos;

        // 출발지로 이동
        moveTruck(source, dest);

        // 화물상차
        myLoad(fId);

        // 목적지로 이동
        source =myTruck.pos;
        dest =freightInfo[fId].dest;
        moveTruck(source, dest);

        // 화물하차
        myUnload();
    }
}
```
